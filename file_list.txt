src/scripts/boards.ts:

import { Ship } from './ships';

type CellStatus = "empty" | "ship" | "miss" | "hit";

interface Cell {
    x: number;
    y: number;
    status: CellStatus;
    ship?: Ship;
}


type Board = Cell[][];

// Función de ayuda para crear un tablero vacío con coordenadas
function createEmptyBoard(size: number): Board {
    const board: Board = [];
    for (let x = 0; x < size; x++) {
        const row: Cell[] = [];
        for (let y = 0; y < size; y++) {
            row.push({
                x,
                y,
                status: "empty"
            });
        }
        board.push(row);
    }
    return board;
}

// Crear tableros de 10x10 con coordenadas
const playerBoard: Board = createEmptyBoard(10);
const computerBoard: Board = createEmptyBoard(10);

export { playerBoard, computerBoard, Board, Cell };

----------------------------------------

src/scripts/game.ts:


----------------------------------------

src/scripts/place.ts:

import {
    playerBoard,
    computerBoard,
    Board,
    Cell,
} from './boards';

import {
    Ship,
    Axis,
    CarrierPlayer,
    BattleshipPlayer,
    DestructorPlayer,
    SubmarinePlayer,
    PatrolPlayer,
    CarrierComputer,
    BattleshipComputer,
    DestructorComputer,
    SubmarineComputer,
    PatrolComputer
} from './ships';

// Retorna true si es seguro colocar el barco en una posición determinada
function canPlaceShip(board: Cell[][], x: number, y: number, shipLength: number, vertical: boolean): boolean {
    const directions = [
        [-1, 0], [1, 0], [0, -1], [0, 1],  // N, S, W, E
        [-1, -1], [-1, 1], [1, -1], [1, 1] // NW, NE, SW, SE
    ];

    for (let i = 0; i < shipLength; i++) {
        const currentX = vertical ? x : x + i;
        const currentY = vertical ? y + i : y;

        if (currentX < 0 || currentY < 0 || currentX >= 10 || currentY >= 10) {
            return false; // out of board
        }

        if (board[currentX][currentY].status === 'ship') {
            return false; // cell already occupied
        }

        for (const [dx, dy] of directions) {
            const newX = currentX + dx;
            const newY = currentY + dy;
            if (newX >= 0 && newY >= 0 && newX < 10 && newY < 10 && board[newX][newY].status === 'ship') {
                return false; // adjacent ship found
            }
        }
    }

    // Verificar que no haya barcos adyacentes
    if (shipLength > 1) {
        for (const [dx, dy] of directions) {
            const adjacentX = x + dx;
            const adjacentY = y + dy;
            if (
                adjacentX >= 0 &&
                adjacentY >= 0 &&
                adjacentX < 10 &&
                adjacentY < 10 &&
                board[adjacentX][adjacentY].status === 'ship'
            ) {
                return false; // barco adyacente encontrado
            }
        }
    }

    return true;
}


// Coloca el barco en el tablero
function placeShip(board: Cell[][], ship: Ship): void {
    let tries = 0;
    const maxTries = 1000;

    while (tries < maxTries) {
        const x = Math.floor(Math.random() * 10);
        const y = Math.floor(Math.random() * 10);
        const vertical = Math.random() < 0.5;

        if (canPlaceShip(board, x, y, ship.length, vertical)) {
            for (let i = 0; i < ship.length; i++) {
                const currentX = vertical ? x : x + i;
                const currentY = vertical ? y + i : y;
                // Aquí asegúrate de asignar un objeto con las propiedades necesarias
                board[currentX][currentY] = {
                    x: currentX,
                    y: currentY,
                    status: 'ship',
                    ship: ship
                };                
            }
            return;
        }

        tries++;
    }

    throw new Error("Unable to place ship after many attempts");
}



function randomPlacement(board: Board, ship: Ship): void {
    let x: number, y: number;
    do {
        const orientations: Axis[] = ['horizontal', 'vertical'];
        ship.axis = orientations[Math.floor(Math.random() * orientations.length)];
        x = Math.floor(Math.random() * board.length);
        y = Math.floor(Math.random() * board.length);
    } while (!canPlaceShip(board, x, y, ship.length, ship.axis === 'vertical'));
    placeShip(board, ship);
}



// Fases de colocación
function playerPlacement(): void {
    try {
        randomPlacement(playerBoard, CarrierPlayer);
        randomPlacement(playerBoard, BattleshipPlayer);
        randomPlacement(playerBoard, DestructorPlayer);
        randomPlacement(playerBoard, SubmarinePlayer);
        randomPlacement(playerBoard, PatrolPlayer);
    } catch (error) {
        resetBoard(playerBoard);
        playerPlacement();
    }
}

function computerPlacement(): void {
    try {
        randomPlacement(computerBoard, CarrierComputer);
        randomPlacement(computerBoard, BattleshipComputer);
        randomPlacement(computerBoard, DestructorComputer);
        randomPlacement(computerBoard, SubmarineComputer);
        randomPlacement(computerBoard, PatrolComputer);
    } catch (error) {
        resetBoard(computerBoard);
        computerPlacement();
    }
}

function resetBoard(board: Cell[][]): void {
    for (let x = 0; x < 10; x++) {
        for (let y = 0; y < 10; y++) {
            board[x][y].status = "empty";
        }
    }
}



export { playerPlacement, computerPlacement };

----------------------------------------

src/scripts/ships.ts:

export type Axis = 'horizontal' | 'vertical';
type Owner = 'playerShip' | 'computerShip';

class Ship {
    length: number;
    axis: Axis;
    owner: Owner;

    constructor(length: number, axis: Axis, owner: Owner) {
        this.length = length;
        this.axis = axis;
        this.owner = owner;
    }
}

// Crear 5 instancias básicas de Ship
// Por defecto, estas instancias serán del jugador. Puedes cambiar el propietario según sea necesario.
const CarrierPlayer = new Ship(5, 'horizontal', 'playerShip');
const BattleshipPlayer = new Ship(4, 'horizontal', 'playerShip');
const DestructorPlayer = new Ship(3, 'horizontal', 'playerShip');
const SubmarinePlayer = new Ship(3, 'horizontal', 'playerShip');
const PatrolPlayer = new Ship(2, 'horizontal', 'playerShip');

const CarrierComputer = new Ship(5, 'horizontal', 'computerShip');
const BattleshipComputer = new Ship(4, 'horizontal', 'computerShip');
const DestructorComputer = new Ship(3, 'horizontal', 'computerShip');
const SubmarineComputer = new Ship(3, 'horizontal', 'computerShip');
const PatrolComputer = new Ship(2, 'horizontal', 'computerShip');

export {
    Ship,
    CarrierPlayer,
    BattleshipPlayer,
    DestructorPlayer,
    SubmarinePlayer,
    PatrolPlayer,
    CarrierComputer,
    BattleshipComputer,
    DestructorComputer,
    SubmarineComputer,
    PatrolComputer
};

----------------------------------------

src/__tests__/place.test.ts:

import { playerPlacement, computerPlacement } from '../scripts/place';
import { playerBoard, computerBoard } from '../scripts/boards';
import {
    CarrierPlayer,
    BattleshipPlayer,
    DestructorPlayer,
    SubmarinePlayer,
    PatrolPlayer,
    CarrierComputer,
    BattleshipComputer,
    DestructorComputer,
    SubmarineComputer,
    PatrolComputer,
} from '../scripts/ships';

describe('Placement Module', () => {
    beforeEach(() => {
        // Reset boards before each test
        for (let x = 0; x < 10; x++) {
            for (let y = 0; y < 10; y++) {
                playerBoard[x][y].status = 'empty';
                computerBoard[x][y].status = 'empty';
            }
        }
    });

    test('There are two placement phases', () => {
        expect(typeof playerPlacement).toBe('function');
        expect(typeof computerPlacement).toBe('function');
    });

    test('Player placement involves playerBoard', () => {
        playerPlacement();
        const playerShips = [CarrierPlayer, BattleshipPlayer, DestructorPlayer, SubmarinePlayer, PatrolPlayer];
        for (const ship of playerShips) {
            const boardStatus = playerBoard.flat().filter(cell => cell.ship && cell.ship === ship);
            expect(boardStatus.length).toBe(ship.length);
        }
    });

    test('Computer placement involves computerBoard', () => {
        computerPlacement();
        const computerShips = [CarrierComputer, BattleshipComputer, DestructorComputer, SubmarineComputer, PatrolComputer];
        for (const ship of computerShips) {
            const boardStatus = computerBoard.flat().filter(cell => cell.ship && cell.ship === ship);
            expect(boardStatus.length).toBe(ship.length);
        }
    });

    test('Ships are placed sequentially', () => {
        playerPlacement();
        const playerShips = [CarrierPlayer, BattleshipPlayer, DestructorPlayer, SubmarinePlayer, PatrolPlayer];
        const playerShipLengths = playerShips.map(ship => ship.length);
        const playerBoardStatus = playerBoard.flat().filter(cell => cell.status === 'ship');

        computerPlacement();
        const computerShips = [CarrierComputer, BattleshipComputer, DestructorComputer, SubmarineComputer, PatrolComputer];
        const computerShipLengths = computerShips.map(ship => ship.length);
        const computerBoardStatus = computerBoard.flat().filter(cell => cell.status === 'ship');

        expect(playerShipLengths).toEqual(playerBoardStatus.map(cell => cell.ship && cell.ship.length));
        expect(computerShipLengths).toEqual(computerBoardStatus.map(cell => cell.ship && cell.ship.length));
    });

    test('Ships can be placed horizontally or vertically', () => {
        playerPlacement();
        const playerShips = [CarrierPlayer, BattleshipPlayer, DestructorPlayer, SubmarinePlayer, PatrolPlayer];
        const playerShipAxes = playerShips.map(ship => ship.axis);
        const playerBoardStatus = playerBoard.flat().filter(cell => cell.status === 'ship');

        computerPlacement();
        const computerShips = [CarrierComputer, BattleshipComputer, DestructorComputer, SubmarineComputer, PatrolComputer];
        const computerShipAxes = computerShips.map(ship => ship.axis);
        const computerBoardStatus = computerBoard.flat().filter(cell => cell.status === 'ship');

        expect(playerShipAxes).toEqual(playerBoardStatus.map(cell => cell.ship && cell.ship.axis));
        expect(computerShipAxes).toEqual(computerBoardStatus.map(cell => cell.ship && cell.ship.axis));
    });

    test('No adjacent ships are placed', () => {
        playerPlacement();
        const playerBoardStatus = playerBoard.flat().filter(cell => cell.status === 'ship');
        let adjacentShips = false;

        for (let i = 0; i < playerBoardStatus.length; i++) {
            const { x, y } = playerBoardStatus[i];
            const directions = [
                [-1, 0], [1, 0], [0, -1], [0, 1],
                [-1, -1], [-1, 1], [1, -1], [1, 1]
            ];

            for (const [dx, dy] of directions) {
                const newX = x + dx;
                const newY = y + dy;

                if (
                    newX >= 0 && newY >= 0 &&
                    newX < 10 && newY < 10 &&
                    playerBoard[newX][newY].status === 'ship'
                ) {
                    adjacentShips = true;
                    break;
                }
            }

            if (adjacentShips) break;
        }

        expect(adjacentShips).toBeFalsy();
    });
});

----------------------------------------

