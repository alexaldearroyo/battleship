src/index.ts:

import "./styles/main.css";
import { playerBoard, computerBoard, Board } from "./scripts/boards";
import {
  manualPlacement,
  playerPlacement,
  computerPlacement,
} from "./scripts/place";


const startButton = document.querySelector(".startButton") as HTMLElement;
const title = document.querySelector(".title") as HTMLElement;
const mainPage = document.querySelector(".mainPage") as HTMLElement;

function startGame() {
  // Elimina el botón de START GAME
  if (startButton) startButton.remove();

  // Envuelve el título en un nuevo div llamado titleSpace
  const titleSpace = document.createElement("div");
  titleSpace.classList.add("titleSpace");

  // Modifica el título para hacerlo más pequeño
  if (title) {
    title.classList.add("smallTitle");
    titleSpace.appendChild(title); // Reinserta el título en titleSpace
  }

  if (mainPage) {
    mainPage.insertBefore(titleSpace, mainPage.firstChild); // Añade titleSpace al inicio de mainPage
  }

  // Crea un nuevo div para boardsSpace
  const boardsSpace = document.createElement("div");
  boardsSpace.classList.add("boardsSpace");

  // Crea divs para playerBoardContainer y computerBoardContainer
  const playerBoardContainer = document.createElement("div");
  playerBoardContainer.classList.add("playerBoardContainer");
  const computerBoardContainer = document.createElement("div");
  computerBoardContainer.classList.add("computerBoardContainer");

  // Crea elementos span para los labels de jugador y computadora
  const playerLabel = document.createElement("span");
  playerLabel.classList.add("playerLabel");
  playerLabel.textContent = "Player";
  playerBoardContainer.appendChild(playerLabel);

  const computerLabel = document.createElement("span");
  computerLabel.classList.add("computerLabel");
  computerLabel.textContent = "Computer";
  computerBoardContainer.appendChild(computerLabel);

  // Añade los tableros a boardsSpace
  boardsSpace.appendChild(playerBoardContainer);
  boardsSpace.appendChild(computerBoardContainer);

  // Llama a las funciones de colocación
  // playerPlacement(); // Comentada esta línea para desactivar la colocación aleatoria
  manualPlacement(playerBoardContainer);
  computerPlacement();

  if (playerBoardContainer && computerBoardContainer) {
    generateGrid(playerBoard, playerBoardContainer);
    generateGrid(computerBoard, computerBoardContainer);
  }

  if (mainPage) {
    mainPage.appendChild(boardsSpace);
  }
}

if (startButton) {
  startButton.addEventListener("click", startGame);
}

function generateGrid(board: Board, container: HTMLElement) {
  const boardSize = board.length; // Obtiene el tamaño del tablero

  // Crea un contenedor para las celdas y aplica la clase "board-container"
  const cellContainer = document.createElement("div");
  cellContainer.classList.add("board-container");

  for (let x = 0; x < boardSize; x++) {
    for (let y = 0; y < boardSize; y++) {
      const cell = document.createElement("div");
      cell.classList.add("cell");

      // Agregar clases CSS según el estado de la celda en el tablero
      switch (board[x][y].status) {
        case "empty":
          cell.classList.add("empty");
          break;
        case "ship":
          cell.classList.add("ship");
          if (container.classList.contains("playerBoardContainer")) {
            // Sólo aplica el color azul si es el tablero del jugador
            cell.classList.add("blue");
          }
          break;
        case "miss":
          cell.classList.add("miss"); // Agregar clase para disparo fallido
          break;
        case "hit":
          cell.classList.add("hit"); // Agregar clase para disparo exitoso
          break;
        default:
          break;
      }

      // Agregar coordenadas como contenido de la celda
      cell.textContent = `${x},${y}`;

      cellContainer.appendChild(cell);

      cell.dataset.x = x.toString();
      cell.dataset.y = y.toString();
    }
  }

  container.appendChild(cellContainer); // Agrega el contenedor de celdas al contenedor principal
}

----------------------------------------

src/scripts/place.ts:

import { playerBoard, computerBoard, Board, Cell } from "./boards";

import {
  Ship,
  Axis,
  CarrierPlayer,
  BattleshipPlayer,
  DestructorPlayer,
  SubmarinePlayer,
  PatrolPlayer,
  CarrierComputer,
  BattleshipComputer,
  DestructorComputer,
  SubmarineComputer,
  PatrolComputer,
} from "./ships";

let shipsToPlace = [
  CarrierPlayer,
  BattleshipPlayer,
  DestructorPlayer,
  SubmarinePlayer,
  PatrolPlayer,
];
let currentShipIndex = 0;
const defaultOrientation: "horizontal" | "vertical" = "horizontal";

function previewShipPlacement(playerBoardContainer: HTMLElement, event: MouseEvent) {
  const cell = event.target as HTMLElement;
  let x: number;
  let y: number;

  if (cell.dataset.x && cell.dataset.y) {
    x = parseInt(cell.dataset.x, 10);
    y = parseInt(cell.dataset.y, 10);

    const ship = shipsToPlace[currentShipIndex];
    const canPlace = canPlaceShip(
      playerBoard,
      x,
      y,
      ship.length,
      defaultOrientation === "vertical"
    );

    // Usar un bucle para iterar sobre las celdas y establecer su color de fondo
    for (let i = 0; i < ship.length; i++) {
      const currentX = defaultOrientation === "vertical" ? x : x + i;
      const currentY = defaultOrientation === "vertical" ? y + i : y;
      const previewCell = document.querySelector(
        `.cell[data-x="${currentX}"][data-y="${currentY}"]`
      );
      if (previewCell) {
        previewCell.classList.toggle("green", canPlace);
        previewCell.classList.toggle("red", !canPlace);
      }
    }
  }
}

function placeCurrentShip(playerBoardContainer: HTMLElement, event: MouseEvent) {
    const cell = event.target as HTMLElement;
    if (cell.dataset.x && cell.dataset.y) {
        const x = parseInt(cell.dataset.x, 10);
        const y = parseInt(cell.dataset.y, 10);
        
        const ship = shipsToPlace[currentShipIndex];
        if (canPlaceShip(playerBoard, x, y, ship.length, defaultOrientation === "vertical")) {
            placeShip(playerBoard, ship);
            const boundPreviewShipPlacement = previewShipPlacement.bind(null, playerBoardContainer);
            const boundPlaceCurrentShip = placeCurrentShip.bind(null, playerBoardContainer);
            playerBoardContainer.removeEventListener("mouseover", boundPreviewShipPlacement);
            currentShipIndex++;

            // Si todos los barcos han sido colocados
            if (currentShipIndex === shipsToPlace.length) {
                playerBoardContainer.removeEventListener("mouseover", boundPreviewShipPlacement);
                playerBoardContainer.removeEventListener("click", boundPlaceCurrentShip);
            }
        }
    }
}

export function manualPlacement(playerBoardContainer: HTMLElement) {
  const boundPreviewShipPlacement = previewShipPlacement.bind(
    null,
    playerBoardContainer
  );
  const boundPlaceCurrentShip = placeCurrentShip.bind(
    null,
    playerBoardContainer
  );

  playerBoardContainer.addEventListener("mouseover", boundPreviewShipPlacement);
  playerBoardContainer.addEventListener("click", boundPlaceCurrentShip);
}

// Retorna true si es seguro colocar el barco en una posición determinada
function canPlaceShip(
  board: Cell[][],
  x: number,
  y: number,
  shipLength: number,
  vertical: boolean
): boolean {
  const directions = [
    [-1, 0],
    [1, 0],
    [0, -1],
    [0, 1], // N, S, W, E
    [-1, -1],
    [-1, 1],
    [1, -1],
    [1, 1], // NW, NE, SW, SE
  ];

  for (let i = 0; i < shipLength; i++) {
    const currentX = vertical ? x : x + i;
    const currentY = vertical ? y + i : y;

    if (currentX < 0 || currentY < 0 || currentX >= 10 || currentY >= 10) {
      return false; // out of board
    }

    if (board[currentX][currentY].status === "ship") {
      return false; // cell already occupied
    }

    for (const [dx, dy] of directions) {
      const newX = currentX + dx;
      const newY = currentY + dy;
      if (
        newX >= 0 &&
        newY >= 0 &&
        newX < 10 &&
        newY < 10 &&
        board[newX][newY].status === "ship"
      ) {
        return false; // adjacent ship found
      }
    }
  }

  // Verificar que no haya barcos adyacentes
  if (shipLength > 1) {
    for (const [dx, dy] of directions) {
      const adjacentX = x + dx;
      const adjacentY = y + dy;
      if (
        adjacentX >= 0 &&
        adjacentY >= 0 &&
        adjacentX < 10 &&
        adjacentY < 10 &&
        board[adjacentX][adjacentY].status === "ship"
      ) {
        return false; // barco adyacente encontrado
      }
    }
  }

  return true;
}

// Coloca el barco en el tablero
function placeShip(board: Cell[][], ship: Ship): void {
  let tries = 0;
  const maxTries = 1000;

  while (tries < maxTries) {
    const x = Math.floor(Math.random() * 10);
    const y = Math.floor(Math.random() * 10);
    const vertical = Math.random() < 0.5;

    if (canPlaceShip(board, x, y, ship.length, vertical)) {
      for (let i = 0; i < ship.length; i++) {
        const currentX = vertical ? x : x + i;
        const currentY = vertical ? y + i : y;
        // Aquí asegúrate de asignar un objeto con las propiedades necesarias
        board[currentX][currentY] = {
          x: currentX,
          y: currentY,
          status: "ship",
          ship: ship,
        };
      }
      return;
    }

    tries++;
  }

  throw new Error("Unable to place ship after many attempts");
}

function randomPlacement(board: Board, ship: Ship): void {
  let x: number, y: number;
  do {
    const orientations: Axis[] = ["horizontal", "vertical"];
    ship.axis = orientations[Math.floor(Math.random() * orientations.length)];
    x = Math.floor(Math.random() * board.length);
    y = Math.floor(Math.random() * board.length);
  } while (!canPlaceShip(board, x, y, ship.length, ship.axis === "vertical"));
  placeShip(board, ship);
}

//////

// Fases de colocación
function playerPlacement(): void {
  try {
    randomPlacement(playerBoard, CarrierPlayer);
    randomPlacement(playerBoard, BattleshipPlayer);
    randomPlacement(playerBoard, DestructorPlayer);
    randomPlacement(playerBoard, SubmarinePlayer);
    randomPlacement(playerBoard, PatrolPlayer);
  } catch (error) {
    resetBoard(playerBoard);
    playerPlacement();
  }
}

function computerPlacement(): void {
  try {
    randomPlacement(computerBoard, CarrierComputer);
    randomPlacement(computerBoard, BattleshipComputer);
    randomPlacement(computerBoard, DestructorComputer);
    randomPlacement(computerBoard, SubmarineComputer);
    randomPlacement(computerBoard, PatrolComputer);
  } catch (error) {
    resetBoard(computerBoard);
    computerPlacement();
  }
}

function resetBoard(board: Cell[][]): void {
  for (let x = 0; x < 10; x++) {
    for (let y = 0; y < 10; y++) {
      board[x][y].status = "empty";
    }
  }
}

export { playerPlacement, computerPlacement };

----------------------------------------

